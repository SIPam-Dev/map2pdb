unit debug.info.writer.yaml;

(*
 * Copyright (c) 2021 Anders Melander
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *)

{$define WRITE_LINES}
{$define WRITE_SYMBOLS}

interface

uses
  Classes,
  debug.info;

type
  TDebugInfoYamlWriter = class
  public
    procedure SaveToStream(Stream: TStream; DebugInfo: TDebugInfo);
    procedure SaveToFile(const Filename: string; DebugInfo: TDebugInfo);
  end;

implementation

uses
  SysUtils,
  Types;

{ TDebugInfoYamlWriter }

procedure TDebugInfoYamlWriter.SaveToFile(const Filename: string; DebugInfo: TDebugInfo);
begin
  var Stream := TFileStream.Create(Filename, fmCreate);
  try

    SaveToStream(Stream, DebugInfo);

  finally
    Stream.Free;
  end;
end;

procedure TDebugInfoYamlWriter.SaveToStream(Stream: TStream; DebugInfo: TDebugInfo);
var
  Level: integer;
  Writer: TStreamWriter;

  procedure WriteLine(const s: string); overload;
  begin
    if (Level > 0) then
      Writer.Write(StringOfChar(' ', Level * 2));
    Writer.WriteLine(s);
  end;

  procedure WriteLine(const Fmt: string; const Args: array of const); overload;
  begin
    WriteLine(Format(Fmt, Args));
  end;

  procedure BeginBlock(const s: string); overload;
  begin
    WriteLine(s);
    Inc(Level);
  end;

  procedure BeginBlock(const Fmt: string; const Args: array of const); overload;
  begin
    BeginBlock(Format(Fmt, Args));
  end;

  procedure EndBlock;
  begin
    Dec(Level);
  end;

const
  Signature: TGUID = '{CBB17264-89FA-4AED-A2D7-814EE276EF3E}';
begin
  Writer := TStreamWriter.Create(Stream);
  try

    Level := 0;

    WriteLine('---');
    WriteLine(Format('# generated by map2yaml %s', [DateTimeToStr(Now)]));

    (*
    ** PDB (PDB Info) stream
    *)
    BeginBlock('PdbStream:');
    begin
      // llvm-pdbutil swaps the values in the GUID that have endianess
      // (this is a bug) so we need to save them "pre-swapped" in the
      // YAML file in order to get the correct value in the PDB file.
      var TweakedSignature := Signature;
      var Bytes := TweakedSignature.ToByteArray(TEndian.Little);
      TweakedSignature := TGUID.Create(Bytes, TEndian.Big);

      WriteLine('Age: 1');
      WriteLine('Guid: ''%s''', [TweakedSignature.ToString]);
      WriteLine('Signature: 1537453107'); // Value doesn't matter
      WriteLine('Features: [ MinimalDebugInfo ]');
//      WriteLine('Features: [ VC110 ]');
      WriteLine('Version: VC70');
    end;
    EndBlock;


    (*
    ** DBI (Debug Info) stream
    *)
    BeginBlock('DbiStream:');
    begin
      WriteLine('VerHeader: V70');
      WriteLine('Age: 1');
//      WriteLine('MachineType: Amd64');
      WriteLine('Flags: 0'); // 2 = private symbols were stripped

      BeginBlock('Modules:');
      begin

        for var Module in DebugInfo.Modules do
        begin
          // Skip module if it doesn't contain any usable source lines
          if (Module.SourceLines.Empty) then
            continue;

          // Skip module if it doesn't contain code
          if (not (Module.SegmentClass.SegClassType in [sctCODE, sctICODE])) then
            continue;

          BeginBlock('- Module: ''%s''', [Module.Name]);
          begin
            BeginBlock('SourceFiles:');
            begin
              for var SourceFile in Module.SourceFiles do
                WriteLine('- ''%s''', [SourceFile.Filename]);
            end;
            EndBlock;

            BeginBlock('Subsections:');
            begin

              BeginBlock('- !FileChecksums');
              begin
                BeginBlock('Checksums:');
                begin
                  for var SourceFile in Module.SourceFiles do
                  begin
                    BeginBlock('- FileName: ''%s''', [SourceFile.Filename]);
                    begin
                      WriteLine('Kind: None');
                      WriteLine('Checksum: ''''');
                    end;
                    EndBlock;
                  end;
                end;
                EndBlock;
              end;
              EndBlock;

{$ifdef WRITE_LINES}
              BeginBlock('- !Lines');
              begin
                WriteLine('CodeSize: %d', [Module.Size]);
                WriteLine('RelocOffset: %0:d # %0:.8X', [Module.Offset]);
                WriteLine('RelocSegment: %d', [Module.SegmentClass.Value]);
                WriteLine('Flags: [ ]');
                BeginBlock('Blocks:');
                begin
                  var LastSourceFile: TDebugInfoSourceFile := nil;
                  for var SourceLine in Module.SourceLines do
                  begin
                    if (SourceLine.SourceFile <> LastSourceFile) then
                    begin
                      if (LastSourceFile <> nil) then
                      begin
                        EndBlock;
                        WriteLine('Columns: [ ]');
                        EndBlock;
                      end;
                      BeginBlock('- FileName: ''%s''', [SourceLine.SourceFile.Filename]);
                      BeginBlock('Lines:');
                      LastSourceFile := SourceLine.SourceFile;
                    end;

                    BeginBlock('- Offset: %d', [SourceLine.Offset]);
                    begin
                      WriteLine('LineStart: %d', [SourceLine.LineNumber]);
                      WriteLine('IsStatement: true');
                      WriteLine('EndDelta: 0');
                    end;
                    EndBlock;
                  end;
                  if (LastSourceFile <> nil) then
                  begin
                    EndBlock;
                    WriteLine('Columns: [ ]');
                    EndBlock;
                  end;
                end;
                EndBlock;
              end;
              EndBlock;
{$endif WRITE_LINES}

            end;
            EndBlock;

{$ifdef WRITE_SYMBOLS}
            (*
            ** Modi (Module Information) stream  - inside the DBI stream
            *)
            BeginBlock('Modi:');
            begin
              WriteLine('Signature: 4'); // 4 = Supposedly means C13 line information
              BeginBlock('Records:');
              begin

                for var Symbol in Module.Symbols do
                begin
                  // Ignore zero size symbols
                  if (Symbol.Size = 0) then
                    continue;

                  BeginBlock('- Kind: S_GPROC32');
                  begin
                    BeginBlock('ProcSym:');
                    begin
                      WriteLine('Segment: %d', [Symbol.Module.SegmentClass.Value]);
                      WriteLine('Offset: %0:d # %0:.8X [%1:.8X]', [Symbol.Offset, Symbol.Module.SegmentClass.Offset+Symbol.Module.Offset+Symbol.Offset]);
                      WriteLine('CodeSize: %d', [Symbol.Size]);
                      WriteLine('DbgStart: 0');
                      WriteLine('DbgEnd: %d', [Symbol.Size-1]);
                      WriteLine('FunctionType: 4097'); // I have no clue...
                      WriteLine('Flags: [ ]');
                      WriteLine('DisplayName: ''%s''', [Symbol.Name]);
                    end;
                    EndBlock;
                  end;
                  EndBlock;

                  (* As far as I can see a S_GPROC32 must be terminated with S_END but it doesn't seem to make a difference.
                  BeginBlock('- Kind: S_END');
                  begin
                    WriteLine('ScopeEndSym: {}');
                  end;
                  EndBlock;
                  *)

                end;
              end;
              EndBlock;
            end;
            EndBlock;
{$endif WRITE_SYMBOLS}

          end;
          EndBlock;
        end;

        (*
        ** Output segments as a special linker module
        *)
        // See: https://reviews.llvm.org/rG28e31ee45e63d7c195e7980c811a15f0b26118cb
        BeginBlock('- Module: ''%s''', ['* Linker *']);
        begin
          WriteLine('ObjFile: ''''');

          BeginBlock('Modi:');
          begin
            WriteLine('Signature: 4');

            BeginBlock('Records:');
            begin
              BeginBlock('- Kind: S_OBJNAME');
              begin
                BeginBlock('ObjNameSym:');
                begin
                  WriteLine('Signature: 0');
                  WriteLine('ObjectName: ''* Linker *''');
                end;
                EndBlock;
              end;
              EndBlock;

              BeginBlock('- Kind: S_COMPILE3');
              begin
                BeginBlock('Compile3Sym:');
                begin
                  WriteLine('Machine: X64');
                  WriteLine('Version: ''Microsoft (R) LINK''');
                  WriteLine('Flags: [ ]');
                  WriteLine('FrontendMajor: 0');
                  WriteLine('FrontendMinor: 0');
                  WriteLine('FrontendBuild: 0');
                  WriteLine('FrontendQFE: 0');
                  WriteLine('BackendMajor: 12');
                  WriteLine('BackendMinor: 0');
                  WriteLine('BackendBuild: 31101');
                  WriteLine('BackendQFE: 0');
                end;
                EndBlock;
              end;
              EndBlock;

              for var SegClassType := Low(TDebugInfoSegmentClassType) to High(TDebugInfoSegmentClassType) do
              begin
                var SegmentClass := DebugInfo.SegmentClasses[SegClassType];
                if (SegmentClass = nil) then
                  continue;

                BeginBlock('- Kind: S_SECTION');
                begin
                  BeginBlock('SectionSym:');
                  begin
                    WriteLine('SectionNumber: %d', [SegmentClass.Value]);
                    WriteLine('Rva: %d', [$1000*SegmentClass.Value]); // Naturally the RVA isn't available so I'm just using "some value" and hoping for the best...
                    WriteLine('Alignment: %d', [12]); // Apparently value is power of 2. Eg. 2^12 = 4096
                    WriteLine('Length: %d', [SegmentClass.Size]);
                    WriteLine('Characteristics: %d', [$60000020]); // TODO
                    WriteLine('Name: %s', [SegmentClass.Name]);
                  end;
                  EndBlock;
                end;
                EndBlock;

                BeginBlock('- Kind: S_COFFGROUP');
                begin
                  BeginBlock('CoffGroupSym:');
                  begin
                    WriteLine('Segment: %d', [SegmentClass.Value]);
                    WriteLine('Offset: %d', [SegmentClass.Offset]);
                    WriteLine('Size: %d', [SegmentClass.Size]);
                    WriteLine('Name: %s', [SegmentClass.Name]);
                    WriteLine('Characteristics: %d', [$60000020]); // TODO
                  end;
                  EndBlock;
                end;
                EndBlock;
              end;
            end;
            EndBlock;
          end;
          EndBlock;
        end;
        EndBlock;

      end;
      EndBlock;
    end;
    EndBlock;

    WriteLine('...');

  finally
    Writer.Free;
  end;
end;

end.

